<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>

<body>
  <style>
    .parent,
    .child,
    .child2 {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .parent {
      width: 400px;
      height: 400px;
      background-color: antiquewhite;
    }

    .child {
      width: 300px;
      height: 300px;
      background-color: aquamarine;
    }

    .child2 {
      width: 200px;
      height: 200px;
      background-color: blueviolet;
    }
  </style>
  <div class="parent">
    parent
    <a class="child" href="https://www.baidu.com">
      child
      <p class="child2">child2</p>
    </a>
  </div>

  <script>
    // 只需要记住事件的执行顺序是 捕获->目标阶段->冒泡
    function parentHandler () {
      console.log('parent');
    }
    function childHandler (event) {
      event.preventDefault()
      console.log('child');
    }
    function child2Handler (event) {
      var e = event ? event : window.event
      e.stopPropagation()
      e.preventDefault()
      console.log('child2');
    }
    let parent = document.querySelector('.parent')
    let child = document.querySelector('.child')
    let child2 = document.querySelector('.child2')
    parent.addEventListener('click', parentHandler, {
      capture: false,
      once: true
    })
    child.addEventListener('click', childHandler, {
      capture: false,
      passive: false
    })
    child2.addEventListener('click', child2Handler, {
      capture: false,
      passive: false
    })
  </script>


  <h2>
    事件流的模型是自上而下捕获, 到达目标, 然后再自下而上冒泡
  </h2>




  <div id="app"></div>


  <!-- <script>
    console.log('tmp', tmp);
    var tmp = new Date();
    console.log(tmp);

    function f () {
      console.log('f, tmp', tmp);
      if (false) {
        console.log('false, tmp, before', tmp);
        var tmp = 'hello world';
        console.log('false, tmp, after', tmp);
      }
    }

    f(); // undefined



  </script> -->
  <script>
    // JS预编译详解
    var a = 1;
    b = 2;
    function test () {
      var c = d = 3;//变量的赋值是从右到左的，相当于：d = 3; var c = d;
      console.log('c', c);
      console.log('d', d);
    }
    test();
    console.log('b', b);
    console.log('d', d);



    var arr = ['8:01', '9:30', '11:50']

    let res = 0;
    arr.forEach(el => {
      res += new Date('2022/01/01 ' + el).getTime()
    })
    console.log(res);
    const aveNum = new Date(res / arr.length)
    console.log(`${aveNum.getHours()}:${aveNum.getMinutes()}`);


    let arr1 = [1, 2, 3, 4]
    let total = arr1.reduce((acc, cur) => {
      console.log(acc, cur);
      return (acc += cur)
    }, 90)
    console.log(total);

    let filterArrResult = [1, 2, 3, 3, 4, 4, null, null].filter((item, index, arr) => arr.indexOf(item) === index)
    console.log(filterArrResult); // [1, 2, 3, 4, null]

    let filterArrResult1 = [1, 2, 2, 4, null, null].reduce((acc, cur) => {
      return acc.includes(cur) ? acc : acc.concat(cur);
    }, []);
    console.log(filterArrResult1);

    let arr2 = [0, [1], [2, 3], [4, [5, 6, 7]]] // 数组扁平化
    let dimensionReduction = function (arr) {
      return arr.reduce((acc, cur) => {
        return acc.concat(
          Array.isArray(cur) ?
            dimensionReduction(cur) :
            cur
        );
      }, []);
    }

    console.log(dimensionReduction(arr2));



    // 求字符串中字母出现的次数
    const str = 'sfhjasfjgfasjuwqrqadqeiqsajsdaiwqdaklldflas-cmxzmnha';
    function getCount (str) {
      const res1 = str.split('').reduce((acc, cur) => {
        acc[cur] ? acc[cur]++ : acc[cur] = 1
        return acc
      }, {})
      return res1
    }
    console.log(getCount(str));
    console.log(getCount('abcbcc'));

    var streams = [{ name: '技术', id: 1 }, { name: '设计', id: 2 }];
    var obj = streams.reduce((acc, cur) => {
      acc[cur.name] = cur;
      return acc;
    }, {})
    console.log(obj);
  </script>
</body>

</html>