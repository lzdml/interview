import{_ as e,c as a,G as n,a0 as t,B as o,o as i}from"./chunks/framework.D62TWaax.js";const p="/interview/assets/live.B73Saujq.png",v=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"web/electron/index.md","filePath":"web/electron/index.md","lastUpdated":1732672553000}'),r={name:"web/electron/index.md"};function c(d,l,u,m,y,b){const s=o("end-time");return i(),a("div",null,[n(s,{time:"2022-11-26 17:20"}),l[0]||(l[0]=t('<h2 id="electron入门笔记" tabindex="-1">Electron入门笔记 <a class="header-anchor" href="#electron入门笔记" aria-label="Permalink to &quot;Electron入门笔记&quot;">​</a></h2><h3 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h3><p><img src="'+p+`" alt="生命周期图"></p><h4 id="应用启动退出的事件介绍" tabindex="-1">应用启动退出的事件介绍 <a class="header-anchor" href="#应用启动退出的事件介绍" aria-label="Permalink to &quot;应用启动退出的事件介绍&quot;">​</a></h4><hr><p>这里把这些事情分为三部分, <strong>App事件, BrowserWindow事件以及Renderer进程中的web事件</strong></p><hr><blockquote><p>App事件介绍</p></blockquote><details class="details custom-block"><summary>事件: will-finish-launching</summary><ul><li><p><strong>返回:</strong> event:Event</p></li><li><p>在windows/linux中与事件ready时机相同, 在 macOS 中相当于 NSApplication 的 applicationWillFinishLaunching 通知，也就是在 NSApplication 开始初始化，默认的通知中心立即发起这个事件，所以一定比ready 事件早。</p></li><li><p><strong>用途:</strong> 常用于open-file和open-url监听器, 并启动崩溃报告和自动更新</p></li></ul></details><details class="details custom-block"><summary>事件: ready</summary><ul><li>返回：event: Event,launchInfo: Record&lt;string, any&gt;</li></ul></details><details class="details custom-block"><summary>事件：open-file[macOS]</summary><ul><li><p>应在 ready 之前对 open-file 进行监听。如果自己接管文件的打开，应该event.preventDefault()</p></li><li><p>触发条件： 应用已经打开，并且通过扩展名或者 macOS 命令行中的 open 命令打开文件的时候，触发 拖放一个文件到 Dock 但应用还没有运行的时候触发</p></li><li><p>Windows 电脑中，需要通过主进程的 process.argv 进行解</p></li></ul></details><details class="details custom-block"><summary>事件：open-url</summary><ul><li><p>返回：event: Event, url: string</p></li><li><p>事件open-url 是系统通过 Electron 应用打开 url 时触发，如果想要自己接管打开url，应该调用event.preventDefault()。并且要在 info.plist 中定义 url scheme，如果是 Electron Builder 打包的，可以找到 extendInfo 配置，能省去很多麻烦。</p></li></ul></details><details class="details custom-block"><summary>事件：activate[macOS]</summary><ul><li><p>返回：event: Event, hasVisibleWindows: boolean</p></li><li><p>事件activate 只会在【首次启动应用程序】、【在程序已经运行后再次打开程序】或【单击应用程序的坞站或任务栏图标时】重新激活它。如果是使用 Cmd+Tab 切换，是不会激活的，这个时候需要did-become-active 。</p></li><li><p>这里的再次打开程序是，macOS 默认是让应用单例模式，如果尝试运行另外一个实例，就会 activate 已经运行的实例。</p></li></ul></details><details class="details custom-block"><summary>事件: did-become-active</summary><ul><li><p>返回：event: Event</p></li><li><p>事件did-become-active则会在切换到这个应用的时候触发，比如没有窗口的应用或者程序第一次启动。</p></li></ul></details><details class="details custom-block"><summary>事件: session-created</summary><ul><li><p>返回：session: Session</p></li><li><p>创建一个 default session，常用于网络请求环境的隔离。</p></li></ul></details><details class="details custom-block"><summary>事件：web-contents-created</summary><ul><li><p>返回：event Event,window: BrowserWindow</p></li><li><p>创建 webContents 的上下文环境就绪。有可能会被初始化多次</p></li></ul></details><details class="details custom-block"><summary>事件：browser-window-created</summary><ul><li>返回：event: Event, window: BrowserWindow</li><li>创建一个窗口，都是依次以 session-created , web-contents-created ,browser-window-created 创建。但不知道为什么在 appready 事件后，又触发了事件 web-contents-created。</li></ul></details><details class="details custom-block"><summary>事件：second-instance</summary><ul><li><p>返回：event: Event, argv: string[],workingDirectory: string</p></li><li><p>在 macOS 中大多数情况启动应用程序是单例模式，当再启动的时候，如果调用了app.requestSingleInstanceLock() 就会在原来运行中的应用触发这个事件，新的应用可以控制是否退出。</p></li></ul></details><details class="details custom-block"><summary>事件：window-all-closed</summary><ul><li>当应用所有窗口关闭后触发，其它情况，比如app.quit、 cmd+q 或者菜单的退出，或者任何其它方式的退出软件都不会触发。</li><li>默认不监听这个事件，关闭所有窗口自动退出应用。一旦监听了这个事件，那么所有窗口关闭后不会退出应用，需要开发者自己控制。</li></ul></details><details class="details custom-block"><summary>事件：before-quit</summary><ul><li><p>返回：event: Event</p></li><li><p>中断：可以</p></li><li><p>任何常规尝试关闭应用的行为都会马上触发。Electron 文档中说autoUpdater.quitAndInstall() 会关闭所有的窗口，然后调用app.quit()。</p></li></ul></details><details class="details custom-block"><summary>事件：will-quit</summary><ul><li><p>返回：event: Event</p></li><li><p>中断：可以</p></li><li><p>在不监听window-all-closed 时，所有的窗口都关闭后触发 will-quit。如果window-all-closed 被监听了， will-quit 被触发了 window-all-closed 也不会被触发。</p></li></ul></details><details class="details custom-block"><summary>事件：quit</summary><ul><li><p>返回：event: Event, exitCode: number</p></li><li><p>在 Windows 系统中，如果应用程序因系统关机/重启或用户注销而关闭，那么 before-quit和 quit 事件不会被触发。</p></li></ul></details><blockquote><p>BrowserWindow 事件介绍</p></blockquote><details class="details custom-block"><summary>事件：close</summary><ul><li><p>返回：event: Event</p></li><li><p>要比 Web 中的 DOM 事件 unload 和 beforeunload 要早，在一般情况下，都是通过 beforeunload 处理窗口关闭的事情：</p></li></ul><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">window</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">onbeforeunload</span><span style="color:#56B6C2;"> =</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;font-style:italic;">e</span><span style="color:#ABB2BF;">) </span><span style="color:#C678DD;">=&gt;</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#E5C07B;">  console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;I do not want to be closed&#39;</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#E5C07B;">  e</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">returnValue</span><span style="color:#56B6C2;"> =</span><span style="color:#D19A66;"> false</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// equivalent to \`return false\` but not recommended}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></details><details class="details custom-block"><summary>事件：closed</summary><ul><li><p>返回：无</p></li><li><p>因为这是个异步事件，所以回调的方法无法影响 BrowserWindow 的生命周期。</p></li></ul></details><details class="details custom-block"><summary>事件：ready-to-show</summary><ul><li><p>返回：无</p></li><li><p>这个窗口属性如果是show:true，也会在没显示的时候就触发事件。</p></li></ul></details><blockquote><p>Renderer 进程中的 Web 事件介绍</p></blockquote><details class="details custom-block"><summary>事件：window:load</summary><ul><li><p>返回：event: Event</p></li><li><p>在窗口开始加载的时候触发，添加监听有两种方法，下面的unlaod和beforeunload 也是一样：</p></li></ul><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">window</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">onload</span><span style="color:#56B6C2;"> =</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;font-style:italic;">event</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">Event</span><span style="color:#ABB2BF;">) </span><span style="color:#C678DD;">=&gt;</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#E5C07B;">  console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">event</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">type</span><span style="color:#ABB2BF;">) </span><span style="color:#7F848E;font-style:italic;">// // output: load}window.addEventListener(&#39;load&#39;, (event: Event) =&gt; {  console.log(event.type)</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></details><details class="details custom-block"><summary>事件：window: unload</summary><ul><li><p>返回：event: Event</p></li><li><p>unload 事件不会被中断。</p></li><li><p>一般情况下，Electron 退出是来不及发出 unload 事件的，只有关闭窗口和重载窗口会发出。</p></li></ul></details><details class="details custom-block"><summary>事件：window:beforeunload</summary><ul><li><p>返回：event: Event</p></li><li><p>中断：可以</p></li><li><p>返回非 undefined 就会中断主进程 BrowserWindow 的 close 事件在窗口重载的时候，也会被触发</p></li></ul></details><details class="details custom-block"><summary>事件：document: DOMContentLoaded</summary><ul><li><p>返回：event: Event</p></li><li><p>等所有 DOM 准备好后触发。</p></li></ul></details><hr>`,32))])}const w=e(r,[["render",c]]);export{v as __pageData,w as default};
