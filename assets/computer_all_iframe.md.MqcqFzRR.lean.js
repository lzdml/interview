import{_ as e,c as l,a0 as t,o as r}from"./chunks/framework.D62TWaax.js";const d=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"computer/all/iframe.md","filePath":"computer/all/iframe.md","lastUpdated":1732672553000}'),i={name:"computer/all/iframe.md"};function o(m,a,s,f,n,c){return r(),l("div",null,a[0]||(a[0]=[t('<h2 id="why-not-iframe" tabindex="-1">Why Not Iframe <a class="header-anchor" href="#why-not-iframe" aria-label="Permalink to &quot;Why Not Iframe&quot;">​</a></h2><p>如果不考虑体验问题，iframe 几乎是最完美的微前端解决方案了。</p><p>iframe 最大的特性就是提供了浏览器原生的硬隔离方案，不论是样式隔离、js 隔离这类问题统统都能被完美解决。但他的最大问题也在于他的隔离性无法被突破，导致应用间上下文无法被共享，随之带来的开发体验、产品体验的问题。</p><ul><li><ol><li>url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。</li></ol></li><li><ol start="2"><li>UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..</li></ol></li><li><ol start="3"><li>全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。</li></ol></li><li><ol start="4"><li>慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。</li></ol></li></ul>',4)]))}const u=e(i,[["render",o]]);export{d as __pageData,u as default};
